package com.clay.web.servlets

import java.util.ResourceBundle
import javax.servlet._
import javax.servlet.annotation.WebFilter
import javax.servlet.http.HttpServletResponse

import org.slf4j.{Logger, LoggerFactory}

/**
  * Default exception handler that convert [[ServletErrorException]] into actual response (return the relevant HTTP/xxx
  * error and generate a standard page).<p>
  *
  * Unhandled exceptions are translated into <i>Internal server error</i> responses.
  *
  * @author Guy Raz Nir
  * @since 16/05/2016
  */
@WebFilter(filterName = "defaultExceptionHandlerFilter", urlPatterns = Array("/*"))
class DefaultExceptionHandlerFilter extends Filter {

    /** Class logger. */
    var logger: Logger = LoggerFactory.getLogger(classOf[DefaultExceptionHandlerFilter])

    /** Contains error messages for each HTTP status code. */
    val message: ResourceBundle = ResourceBundle.getBundle("HttpStatusMessages")

    /**
      * Filter initialization callback.
      *
      * @param filterConfig Filter configuration.
      */
    override def init(filterConfig: FilterConfig): Unit = {
        logger.info("Default exception filter initialized.")
    }

    /**
      * Call the next filter/servlet in chain and catch any exception generated by the call. If [[ServletErrorException]]
      * is caught, it's HTTP status code is forwarded to the caller. If any other exception is caught,
      * [[HttpServletResponse.SC_INTERNAL_SERVER_ERROR Internal server error]] is forwarded to client.
      *
      * @param request  Servlet request.
      * @param response Servlet response (assumed to be [[HttpServletResponse]]).
      * @param chain    Next chain in the execution.
      */
    override def doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain): Unit = {
        val httpResponse: HttpServletResponse = response.asInstanceOf[HttpServletResponse]

        try {
            chain.doFilter(request, response)
        } catch {
            case error: ServletErrorException =>
                val message: String = getErrorMessage(error)
                logger.warn("Servlet error: HTTP/{} -- {}", error.statusCode, message)
                logger.debug("Servlet error.", error)
                httpResponse.sendError(error.statusCode, message)

            case ex: Exception =>
                logger.error("Unexpected internal server error.", ex)
                httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, getErrorMessage(HttpServletResponse.SC_INTERNAL_SERVER_ERROR))

            case tr: Throwable =>
                logger.error("Unexpected critical internal server error.", tr)
                httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, getErrorMessage(HttpServletResponse.SC_INTERNAL_SERVER_ERROR))
        }
    }

    /**
      * Filter shutdown callback.
      */
    override def destroy(): Unit = {
        logger.info("Default exception filter destroyed.")
    }

    /**
      * Generate error message for given exception by using either message encapsulated within the exception or
      * default message from external resources bundle.
      *
      * @param ex Exception to generate message for.
      * @return Generated message (or `null` if no message could be generated for given error code).
      */
    private def getErrorMessage(ex: ServletErrorException): String = {
        // If exception carries error message use it. Otherwise, try to locate default error message for the
        // given HTTP status.
        if (ex.getMessage != null) {
            ex.getMessage
        } else {
            getErrorMessage(ex.statusCode)
        }
    }

    /**
      * Fetch default error message for a given HTTP status code.
      *
      * @param statusCode HTTP status code.
      * @return Generated message (or `null` if no message could be generated for given error code).
      */
    private def getErrorMessage(statusCode: Int): String = {
        // Extract message from resource bundle, handle case of no matching error message.
        try {
            message.getString("http.status." + statusCode)
        } catch {
            // No default error message found for given status code.
            case _: Throwable => null
        }
    }
}
